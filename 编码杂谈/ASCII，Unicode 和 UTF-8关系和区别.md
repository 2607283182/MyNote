## ASCLL编码
1byte = 8bit = 8个二进制位 = 2的8次方 = 256 

所以1byte可以标识256种状态

ASCLL编码只使用了后七位，第一位默认是0，因为当时128足以表示所有字符(2的7次方)。
## Unicode编码
后来，互联网的出现，导致了256种状态不足以表示所有的字面量，那么怎么办，扩展被，用多个8位bit，也就是多个byte表示一个字面量。

比如 ： 中文字符 ‘松’ 可能会用2个甚至3个byte表示。

可以用这样的方式表示，但是还有一种问题，如果有一个字符用了5个byte表示，那么所有的字符都用5个byte表示？太费容量了啊，

原来用一个byte可以表示的 'a' 字符，现在也得跟着需要2个的byte个数的字符的 ‘松’ 来表示，那么太费存储了啊。
## UTF-8编码
那只能用种折中的方式，表示Unicode了，那就是UTF-8等等，这是个可变的字符编码。

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

### 编码规则如下图

```
Unicode符号范围     |        UTF-8编码方式
(十六进制)        |              （二进制）
----------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
```

举例：
跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

下面，还是以汉字严为例，演示如何实现 UTF-8 编码。

严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。

这样，虽然中文字符 ‘严’ 用Unicode表示是2位字符，用UTF-8就变成3位了，但是文档里的所有英文字符还是一位，省了很多。。。

## 大端存储和小端存储
以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。

这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。

第一个字节在前，就是"大头方式"（Big endian），第二个字节在前就是"小头方式"（Little endian）。

那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？

Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。

如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。

## 参考文献之喝水不忘打井人
http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html